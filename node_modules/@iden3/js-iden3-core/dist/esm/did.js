import { Id } from './id';
import { Constants } from './constants';
export var Blockchain;
(function (Blockchain) {
    Blockchain["Ethereum"] = "eth";
    Blockchain["Polygon"] = "polygon";
    Blockchain["Unknown"] = "unknown";
    Blockchain["NoChain"] = "";
})(Blockchain || (Blockchain = {}));
export var NetworkId;
(function (NetworkId) {
    NetworkId["Main"] = "main";
    NetworkId["Mumbai"] = "mumbai";
    NetworkId["Goerli"] = "goerli";
    NetworkId["Unknown"] = "unknown";
    NetworkId["NoNetwork"] = "";
})(NetworkId || (NetworkId = {}));
export var DidMethod;
(function (DidMethod) {
    DidMethod["Iden3"] = "iden3";
    DidMethod["PolygonId"] = "polygonid";
})(DidMethod || (DidMethod = {}));
export const DIDMethodByte = {
    [DidMethod.Iden3]: 0b00000001,
    [DidMethod.PolygonId]: 0b00000010
};
// DIDNetworkFlag is a structure to represent DID blockchain and network id
export class DIDNetworkFlag {
    constructor(blockchain, networkId) {
        this.blockchain = blockchain;
        this.networkId = networkId;
    }
    toString() {
        return `${this.blockchain || '_'}:${this.networkId || '_'}`;
    }
    static fromString(s) {
        const [blockchain, networkId] = s.split(':');
        return new DIDNetworkFlag(blockchain.replace('_', ''), networkId.replace('_', ''));
    }
}
// DIDMethodNetwork is map for did methods and their blockchain networks
export const DIDMethodNetwork = {
    [DidMethod.Iden3]: {
        '_:_': 0b00000000,
        'polygon:main': 0b00010000 | 0b00000001,
        'polygon:mumbai': 0b00010000 | 0b00000010,
        'ethereum:main': 0b00100000 | 0b00000001,
        'ethereum:goerli': 0b00100000 | 0b00000010
    },
    [DidMethod.PolygonId]: {
        '_:_': 0b00000000,
        'polygon:main': 0b00010000 | 0b00000001,
        'polygon:mumbai': 0b00010000 | 0b00000010
    }
};
// BuildDIDType builds bytes type from chain and network
export function buildDIDType(method, blockchain, network) {
    const fb = DIDMethodByte[method];
    if (!fb) {
        throw new Error(`method ${method} is not defined in core lib`);
    }
    const methodFn = DIDMethodNetwork[method];
    if (!methodFn) {
        throw new Error(`method ${method} is not defined in core lib`);
    }
    const sb = methodFn[new DIDNetworkFlag(blockchain, network).toString()];
    if (typeof sb !== 'number') {
        throw new Error(`blockchain ${blockchain.toString() ?? '-'} and network ${network.toString() ?? '-'} is not defined in core lib`);
    }
    return Uint8Array.from([fb, sb]);
}
// FindNetworkIDForDIDMethodByValue finds network by byte value
export function findNetworkIDForDIDMethodByValue(method, byteNumber) {
    const methodMap = DIDMethodNetwork[method];
    if (!methodMap) {
        throw new Error(`${Constants.ERRORS.DID_METHOD_NOT_SUPPORTED}: did method ${method} is not defined in core lib`);
    }
    for (const [key, value] of Object.entries(methodMap)) {
        if (value === byteNumber) {
            return DIDNetworkFlag.fromString(key).networkId;
        }
    }
    throw new Error(`${Constants.ERRORS.DID_METHOD_NOT_SUPPORTED}: bytes ${byteNumber} for did method ${method} is not defined in core lib as a valid network identifer`);
}
// findBlockchainForDIDMethodByValue finds blockchain type by byte value
export function findBlockchainForDIDMethodByValue(method, byteNumber) {
    const methodMap = DIDMethodNetwork[method];
    if (!methodMap) {
        throw new Error(`${Constants.ERRORS.NETWORK_NOT_SUPPORTED_FOR_DID}: did method ${method} is not defined in core lib`);
    }
    for (const [key, value] of Object.entries(methodMap)) {
        if (value === byteNumber) {
            return DIDNetworkFlag.fromString(key).blockchain;
        }
    }
    throw new Error(`${Constants.ERRORS.NETWORK_NOT_SUPPORTED_FOR_DID}: bytes ${byteNumber} for did method ${method} is not defined in core lib as a valid blockchain network`);
}
// findDIDMethodByValue finds did method by its byte value
export function findDIDMethodByValue(byteNumber) {
    for (const [key, value] of Object.entries(DIDMethodByte)) {
        if (value === byteNumber) {
            return key;
        }
    }
    throw new Error(`${Constants.ERRORS.DID_METHOD_NOT_SUPPORTED}: bytes ${byteNumber} are not defined in core lib as valid did method`);
}
// DID Decentralized Identifiers (DIDs)
// https://w3c.github.io/did-core/#did-syntax
export class DID {
    constructor() {
        this.method = DidMethod.Iden3;
        this.id = new Id(new Uint8Array(2), new Uint8Array(27));
        this.blockchain = Blockchain.NoChain;
        this.networkId = NetworkId.NoNetwork;
    }
    // DIDGenesisFromIdenState calculates the genesis ID from an Identity State and returns it as DID
    static fromGenesisFromIdenState(typ, state) {
        const id = Id.idGenesisFromIdenState(typ, state);
        return DID.parseFromId(id);
    }
    // toString did as a string
    toString() {
        if (this.blockchain == '') {
            return [Constants.DID.DID_SCHEMA, this.method, this.id.string()].join(':');
        }
        return [
            Constants.DID.DID_SCHEMA,
            this.method,
            this.blockchain,
            this.networkId,
            this.id.string()
        ]
            .filter((i) => !!i)
            .join(':');
    }
    // ParseDIDFromID returns did from ID
    static parseFromId(id) {
        const did = new DID();
        did.id = id;
        const typ = id.type();
        did.method = findDIDMethodByValue(typ[0]);
        did.blockchain = findBlockchainForDIDMethodByValue(did.method, typ[1]);
        did.networkId = findNetworkIDForDIDMethodByValue(did.method, typ[1]);
        return did;
    }
    // ParseDID method parse string and extract DID if string is valid Iden3 identifier
    static parse(s) {
        const args = s.split(':');
        if (args.length <= 1) {
            throw new Error(`${Constants.ERRORS.INVALID_DID}: did string is not valid`);
        }
        const did = new DID();
        did.method = args[1];
        switch (args.length) {
            case 5:
                // validate id
                did.id = Id.fromString(args[4]);
                did.blockchain = args[2];
                did.networkId = args[3];
                break;
            case 3:
                // validate readonly id
                did.id = Id.fromString(args[2]);
                did.blockchain = Blockchain.NoChain;
                did.networkId = NetworkId.NoNetwork;
                break;
        }
        // check did method defined in core lib
        const methodByte = DIDMethodByte[did.method];
        if (!methodByte) {
            throw new Error(`${Constants.ERRORS.DID_METHOD_NOT_SUPPORTED}: DIDMethodByte: did method ${did.method} is not defined in core lib`);
        }
        // check did network defined in core lib for did method
        const method = DIDMethodNetwork[did.method];
        if (!method) {
            throw new Error(`${Constants.ERRORS.NETWORK_NOT_SUPPORTED_FOR_DID}: DIDMethodNetwork: did method ${did.method} is not defined in core lib`);
        }
        const byte = method[new DIDNetworkFlag(did.blockchain, did.networkId).toString()];
        if (!byte?.toString()) {
            throw new Error(`${Constants.ERRORS.INVALID_DID}: blockchain network "${did.blockchain} ${did.networkId}" is not defined for ${did.method} did method`);
        }
        // check id contains did network and method
        const d = DID.parseFromId(did.id);
        if (d.method !== did.method) {
            throw new Error(`${Constants.ERRORS.INVALID_DID}: did method of core identity ${did.method} differs from given did method ${did.method}`);
        }
        if (d.networkId !== did.networkId) {
            throw new Error(`${Constants.ERRORS.INVALID_DID}: network method of core identity ${d.networkId} differs from given did network specific id ${did.networkId}`);
        }
        if (d.blockchain !== did.blockchain) {
            throw new Error(`${Constants.ERRORS.INVALID_DID}: blockchain network of core identity ${d.blockchain} differs from given did blockchain network ${did.blockchain}`);
        }
        return did;
    }
}
//# sourceMappingURL=did.js.map