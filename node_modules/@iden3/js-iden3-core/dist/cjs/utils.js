"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.idenState = exports.checkBigIntArrayInField = exports.checkBigIntInField = exports.getDateFromUnixTimestamp = exports.getUnixTimestamp = exports.getUint64 = exports.putUint64 = exports.getUint32 = exports.putUint32 = exports.toBigEndian = exports.toLittleEndian = exports.fromBigEndian = exports.fromLittleEndian = void 0;
const js_crypto_1 = require("@iden3/js-crypto");
const constants_1 = require("./constants");
// eslint-disable-next-line @typescript-eslint/no-var-requires
function fromLittleEndian(bytes) {
    const n256 = BigInt(256);
    let result = BigInt(0);
    let base = BigInt(1);
    bytes.forEach((byte) => {
        result += base * BigInt(byte);
        base = base * n256;
    });
    return result;
}
exports.fromLittleEndian = fromLittleEndian;
function fromBigEndian(bytes) {
    return fromLittleEndian(bytes.reverse());
}
exports.fromBigEndian = fromBigEndian;
function toLittleEndian(bigNumber, len = 31) {
    const n256 = BigInt(256);
    const result = new Uint8Array(len);
    let i = 0;
    while (bigNumber > BigInt(0)) {
        result[i] = Number(bigNumber % n256);
        bigNumber = bigNumber / n256;
        i += 1;
    }
    return result;
}
exports.toLittleEndian = toLittleEndian;
function toBigEndian(bigNumber, len = 31) {
    return toLittleEndian(bigNumber, len).reverse();
}
exports.toBigEndian = toBigEndian;
function putUint32(n) {
    const buf = new ArrayBuffer(4);
    const view = new DataView(buf);
    view.setUint32(0, n, true);
    return new Uint8Array(buf);
}
exports.putUint32 = putUint32;
function getUint32(arr) {
    const buf = arr.buffer.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
    return new DataView(buf).getUint32(0, true);
}
exports.getUint32 = getUint32;
function putUint64(n) {
    const buf = new ArrayBuffer(8);
    const view = new DataView(buf);
    view.setBigUint64(0, n, true);
    return new Uint8Array(buf);
}
exports.putUint64 = putUint64;
function getUint64(arr) {
    const buf = arr.buffer.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
    return new DataView(buf).getBigUint64(0, true);
}
exports.getUint64 = getUint64;
function getUnixTimestamp(d) {
    return Math.floor(d.getTime() / 1000);
}
exports.getUnixTimestamp = getUnixTimestamp;
function getDateFromUnixTimestamp(n) {
    return new Date(n * 1000);
}
exports.getDateFromUnixTimestamp = getDateFromUnixTimestamp;
// checkBigIntInField checks if given *big.Int fits in a Field Q element
function checkBigIntInField(a) {
    return a < constants_1.Constants.Q;
}
exports.checkBigIntInField = checkBigIntInField;
function checkBigIntArrayInField(arr) {
    return arr.every((n) => checkBigIntInField(n));
}
exports.checkBigIntArrayInField = checkBigIntArrayInField;
// IdenState calculates the Identity State from the Claims Tree Root,
// Revocation Tree Root and Roots Tree Root.
function idenState(clr, rer, ror) {
    return js_crypto_1.poseidon.hash([clr, rer, ror]);
}
exports.idenState = idenState;
//# sourceMappingURL=utils.js.map