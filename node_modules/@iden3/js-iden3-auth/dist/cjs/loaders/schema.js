"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLoader = exports.IpfsSchemaLoader = exports.HttpSchemaLoader = exports.UniversalSchemaLoader = void 0;
const axios_1 = __importDefault(require("axios"));
const ipfs_http_client_1 = require("ipfs-http-client");
class UniversalSchemaLoader {
    constructor(ipfsUrl) {
        this.ipfsUrl = ipfsUrl;
    }
    async load(url) {
        const l = getLoader(url, this.ipfsUrl);
        const schemaRes = await l.load(url);
        return schemaRes;
    }
}
exports.UniversalSchemaLoader = UniversalSchemaLoader;
class HttpSchemaLoader {
    async load(url) {
        const resp = await axios_1.default.get(url, { responseType: 'arraybuffer' });
        return {
            schema: resp.data,
            extension: 'json-ld',
        };
    }
}
exports.HttpSchemaLoader = HttpSchemaLoader;
class IpfsSchemaLoader {
    constructor(url) {
        this.url = url;
        this.client = (0, ipfs_http_client_1.create)({ url: this.url });
    }
    async load(url) {
        const uri = new URL(url);
        const schemaRes = this.client.cat(uri.host);
        let schemaBytes;
        for await (const num of schemaRes) {
            schemaBytes = Uint8Array.from(num);
        }
        return {
            schema: schemaBytes,
            extension: 'json-ld',
        };
    }
}
exports.IpfsSchemaLoader = IpfsSchemaLoader;
// TODO: IPFS URL FOR BROWSER
function getLoader(url, ipfsConfigUrl) {
    const uri = new URL(url);
    switch (uri.protocol) {
        case 'http:':
        case 'https:':
            return new HttpSchemaLoader();
        case 'ipfs:':
            return new IpfsSchemaLoader(ipfsConfigUrl);
        default:
            throw new Error(`loader for ${uri.protocol} is not supported`);
    }
}
exports.getLoader = getLoader;
//# sourceMappingURL=schema.js.map