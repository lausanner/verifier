"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Verifier = exports.createAuthorizationRequestWithMessage = exports.createAuthorizationRequest = void 0;
const uuid_1 = require("uuid");
const constants_1 = require("../protocol/constants");
const zk_1 = require("../proofs/zk");
const registry_1 = require("../circuits/registry");
const js_jwz_1 = require("@iden3/js-jwz");
const js_iden3_core_1 = require("@iden3/js-iden3-core");
function createAuthorizationRequest(reason, sender, callbackUrl) {
    return createAuthorizationRequestWithMessage(reason, '', sender, callbackUrl);
}
exports.createAuthorizationRequest = createAuthorizationRequest;
function createAuthorizationRequestWithMessage(reason, message, sender, callbackUrl) {
    const uuid = (0, uuid_1.v4)();
    const request = {
        id: uuid,
        thid: uuid,
        from: sender,
        typ: constants_1.MEDIA_TYPE_PLAIN,
        type: constants_1.AUTHORIZATION_REQUEST_MESSAGE_TYPE,
        body: {
            reason: reason,
            message: message,
            callbackUrl: callbackUrl,
            scope: [],
        },
    };
    return request;
}
exports.createAuthorizationRequestWithMessage = createAuthorizationRequestWithMessage;
class Verifier {
    constructor(keyLoader, schemaLoader, stateResolver) {
        this.keyLoader = keyLoader;
        this.schemaLoader = schemaLoader;
        this.stateResolver = stateResolver;
    }
    async verifyAuthResponse(response, request, opts) {
        if ((request.body.message ?? '') !== (response.body.message ?? '')) {
            throw new Error('message for signing from request is not presented in response');
        }
        for (const proofRequest of request.body.scope) {
            const proofResp = response.body.scope.find((proofResp) => proofResp.id === proofRequest.id);
            if (!proofResp) {
                throw new Error(`proof is not given for requestId ${proofRequest.id}`);
            }
            if (proofResp.circuitId !== proofRequest.circuitId) {
                throw new Error(`proof is not given for requested circuit expected: ${proofRequest.circuitId}, given ${proofResp.circuitId}`);
            }
            const circuitId = proofResp.circuitId;
            const key = await this.keyLoader.load(circuitId);
            if (!key) {
                throw new Error(`verification key is not found for circuit ${circuitId}`);
            }
            const jsonKey = JSON.parse(new TextDecoder().decode(key));
            const isValid = await (0, zk_1.verifyProof)(proofResp, jsonKey);
            if (!isValid) {
                throw new Error(`Proof with circuit id ${circuitId} and request id ${proofResp.id} is not valid`);
            }
            const CircuitVerifier = registry_1.Circuits.getCircuitPubSignals(circuitId);
            if (!CircuitVerifier) {
                throw new Error(`circuit ${circuitId} is not supported by the library`);
            }
            // verify query
            const verifier = new CircuitVerifier(proofResp.pub_signals);
            await verifier.verifyQuery(proofRequest.query, this.schemaLoader, proofResp.vp);
            // verify states
            await verifier.verifyStates(this.stateResolver, opts);
            // verify id ownership
            await verifier.verifyIdOwnership(response.from, BigInt(proofResp.id));
        }
    }
    async verifyJWZ(tokenStr, opts) {
        const token = await js_jwz_1.Token.parse(tokenStr);
        const key = await this.keyLoader.load(token.circuitId);
        if (!key) {
            throw new Error(`verification key is not found for circuit ${token.circuitId}`);
        }
        const isValid = await token.verify(key);
        if (!isValid) {
            throw new Error(`zero-knowledge proof of jwz token is not valid`);
        }
        const CircuitVerifier = registry_1.Circuits.getCircuitPubSignals(token.circuitId);
        if (!CircuitVerifier) {
            throw new Error(`circuit ${token.circuitId} is not supported by the library`);
        }
        // outputs unmarshaller
        const verifier = new CircuitVerifier(token.zkProof.pub_signals);
        // state verification
        await verifier.verifyStates(this.stateResolver, opts);
        return token;
    }
    async fullVerify(tokenStr, request, opts) {
        const token = await this.verifyJWZ(tokenStr, opts);
        const payload = token.getPayload();
        const response = JSON.parse(payload.toString());
        /*
          verify that sender of AuthorizationResponseMessage is in token zkproof pubsignals
        */
        const signalsVerifierType = registry_1.Circuits.getCircuitPubSignals(token.circuitId);
        const signalsVerifier = new signalsVerifierType(token.zkProof.pub_signals);
        await signalsVerifier.verifyIdOwnership(response.from, (0, js_iden3_core_1.fromBigEndian)(await token.getMessageHash()));
        await this.verifyAuthResponse(response, request, opts);
        return response;
    }
}
exports.Verifier = Verifier;
//# sourceMappingURL=auth.js.map