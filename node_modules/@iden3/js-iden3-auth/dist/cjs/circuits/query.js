"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSchemaHash = exports.checkQueryRequest = void 0;
const nested_property_1 = __importDefault(require("nested-property"));
const js_iden3_core_1 = require("@iden3/js-iden3-core");
const js_jsonld_merklization_1 = require("@iden3/js-jsonld-merklization");
const keccak256_1 = __importDefault(require("keccak256"));
const xsdtypes = __importStar(require("jsonld/lib/constants"));
const operators = new Map([
    ['$noop', 0],
    ['$eq', 1],
    ['$lt', 2],
    ['$gt', 3],
    ['$in', 4],
    ['$nin', 5],
    ['$ne', 6],
]);
const allOperations = new Set(operators.values());
const availableTypesOperators = new Map([
    [xsdtypes.XSD_BOOLEAN, new Set([operators.get('$eq'), operators.get('$ne')])],
    [xsdtypes.XSD_INTEGER, allOperations],
    [xsdtypes.XSD_INTEGER + 'nonNegativeInteger', allOperations],
    [xsdtypes.XSD_INTEGER + 'positiveInteger', allOperations],
    [
        xsdtypes.XSD_STRING,
        new Set([
            operators.get('$eq'),
            operators.get('$ne'),
            operators.get('$in'),
            operators.get('$nin'),
        ]),
    ],
    [xsdtypes.XSD_DATE, allOperations],
]);
const serializationIndexDataSlotAType = 'serialization:IndexDataSlotA';
const serializationIndexDataSlotBType = 'serialization:IndexDataSlotB';
const serializationValueDataSlotAType = 'serialization:ValueDataSlotA';
const serializationValueDataSlotBType = 'serialization:ValueDataSlotB';
async function checkQueryRequest(query, outputs, schemaLoader, verifiablePresentation) {
    // validate issuer
    let userDID;
    try {
        userDID = js_iden3_core_1.DID.parseFromId(outputs.issuerId);
    }
    catch (e) {
        throw new Error("invalid issuerId in circuit's output");
    }
    const issuerAllowed = query.allowedIssuers.some((issuer) => issuer === '*' || issuer === userDID.toString());
    if (!issuerAllowed) {
        throw new Error('issuer is not in allowed list');
    }
    // validate schema
    let loadResult;
    try {
        loadResult = await schemaLoader.load(query.context);
    }
    catch (e) {
        throw new Error(`can't load schema for request query`);
    }
    const schemaHash = createSchemaHash(query.context, query.type);
    if (schemaHash.bigInt() !== outputs.schemaHash.bigInt()) {
        throw new Error(`schema that was used is not equal to requested in query`);
    }
    if (!query.skipClaimRevocationCheck && outputs.isRevocationChecked === 0) {
        throw new Error(`check revocation is required`);
    }
    const cq = await parseRequest(query, outputs, loadResult.schema);
    // validate selective disclosure
    if (cq.isSelectiveDisclosure) {
        try {
            await validateDisclosure(verifiablePresentation, cq, outputs);
        }
        catch (e) {
            throw new Error(`failed to validate selective disclosure: ${e.message}`);
        }
    }
    else {
        try {
            await validateOperators(cq, outputs);
        }
        catch (e) {
            throw new Error(`failed to validate operators: ${e.message}`);
        }
    }
    // verify claim
    if (outputs.merklized === 1) {
        if (outputs.claimPathKey !== cq.claimPathKey) {
            throw new Error(`proof was generated for another path`);
        }
        if (outputs.claimPathNotExists === 1) {
            throw new Error(`proof doesn't contains target query key`);
        }
    }
    else {
        if (outputs.slotIndex !== cq.slotIndex) {
            throw new Error(`wrong claim slot was used in claim`);
        }
    }
    return;
}
exports.checkQueryRequest = checkQueryRequest;
async function validateOperators(cq, outputs) {
    if (outputs.operator !== cq.operator) {
        throw new Error(`operator that was used is not equal to request`);
    }
    if (outputs.operator === operators.get('$noop')) {
        // for noop operator slot and value are not used in this case
        return;
    }
    for (let index = 0; index < outputs.value.length; index++) {
        if (outputs.value[index] !== cq.values[index]) {
            throw new Error(`comparison value that was used is not equal to requested in query`);
        }
    }
}
async function validateDisclosure(verifiablePresentation, cq, outputs) {
    if (!verifiablePresentation) {
        throw new Error(`verifiablePresentation is required for selective disclosure request`);
    }
    if (outputs.operator !== operators.get('$eq')) {
        throw new Error(`operator for selective disclosure must be $eq`);
    }
    for (let index = 1; index < outputs.value.length; index++) {
        if (outputs.value[index] !== 0n) {
            throw new Error(`selective disclosure not available for array of values`);
        }
    }
    let mz;
    const strVerifiablePresentation = JSON.stringify(verifiablePresentation);
    try {
        mz = await js_jsonld_merklization_1.Merklizer.merklizeJSONLD(strVerifiablePresentation);
    }
    catch (e) {
        throw new Error(`can't merkelize verifiablePresentation`);
    }
    let merklizedPath;
    try {
        const p = `verifiableCredential.credentialSubject.${cq.fieldName}`;
        merklizedPath = await js_jsonld_merklization_1.Path.fromDocument(null, strVerifiablePresentation, p);
    }
    catch (e) {
        throw new Error(`can't build path to '${cq.fieldName}' key`);
    }
    let proof;
    let value;
    try {
        ({ proof, value } = await mz.proof(merklizedPath));
    }
    catch (e) {
        throw new Error(`can't get value by path '${cq.fieldName}'`);
    }
    if (!proof.existence) {
        throw new Error(`path [${merklizedPath.parts}] doesn't exist in verifiablePresentation document`);
    }
    const bi = await value.mtEntry();
    if (bi !== outputs.value[0]) {
        throw new Error(`value that was used is not equal to requested in query`);
    }
    return;
}
async function parseRequest(query, outputs, schema) {
    if (!query.credentialSubject) {
        return {
            operator: operators.get('$noop'),
            values: null,
            slotIndex: 0,
            isSelectiveDisclosure: false,
            fieldName: '',
        };
    }
    if (Object.keys(query.credentialSubject).length > 1) {
        throw new Error(`multiple requests not supported`);
    }
    const txtSchema = new TextDecoder().decode(schema);
    let fieldName;
    let predicate;
    for (const [key, value] of Object.entries(query.credentialSubject)) {
        fieldName = key;
        predicate = value;
        if (Object.keys(predicate).length > 1) {
            throw new Error(`multiple predicates for one field not supported`);
        }
        break;
    }
    let datatype;
    if (fieldName !== '') {
        datatype = await js_jsonld_merklization_1.Path.newTypeFromContext(txtSchema, `${query.type}.${fieldName}`);
    }
    const [operator, values] = await parsePredicate(predicate, datatype);
    const zeros = Array.from({
        length: outputs.valueArraySize - values.length,
    }).fill(BigInt(0));
    const fullArray = values.concat(zeros);
    const [claimPathKey, slotIndex] = await verifyClaim(outputs.merklized, txtSchema, query.type, fieldName);
    const cq = {
        claimPathKey,
        slotIndex,
        operator,
        values: fullArray,
        isSelectiveDisclosure: false,
        fieldName,
    };
    if (Object.keys(predicate).length === 0) {
        cq.isSelectiveDisclosure = true;
    }
    return cq;
}
function getFieldSlotIndex(fieldName, credentialType, schema) {
    const obj = JSON.parse(Buffer.from(schema).toString('utf-8'));
    const type = nested_property_1.default.get(obj, `@context.0.${credentialType}.@context.${fieldName}.@type`);
    switch (type) {
        case serializationIndexDataSlotAType:
            return 2;
        case serializationIndexDataSlotBType:
            return 3;
        case serializationValueDataSlotAType:
            return 6;
        case serializationValueDataSlotBType:
            return 7;
        default:
            return -1;
    }
}
// TODO (illia-korotia): move to core like static method or contructor of SchemaHash type.
function createSchemaHash(schemaContext, type) {
    const schemaID = new TextEncoder().encode(`${schemaContext}#${type}`);
    const bytes = new Uint8Array([...schemaID]);
    const h = (0, keccak256_1.default)(Buffer.from(bytes));
    return new js_iden3_core_1.SchemaHash(h.slice(-16));
}
exports.createSchemaHash = createSchemaHash;
async function getValuesAsArray(v, datatype) {
    const values = [];
    if (Array.isArray(v)) {
        for (let index = 0; index < v.length; index++) {
            if (!isPositiveInteger(v[index])) {
                throw new Error(`value must be positive integer`);
            }
            values[index] = await js_jsonld_merklization_1.Merklizer.hashValue(datatype, v[index]);
        }
        return values;
    }
    if (!isPositiveInteger(v)) {
        throw new Error(`value must be positive integer`);
    }
    values[0] = await js_jsonld_merklization_1.Merklizer.hashValue(datatype, v);
    return values;
}
function isPositiveInteger(value) {
    if (!Number.isInteger(value)) {
        return true;
    }
    return value >= 0;
}
function isValidOperation(datatype, op) {
    if (op === operators.get('$noop')) {
        return true;
    }
    if (!availableTypesOperators.has(datatype)) {
        return false;
    }
    const ops = availableTypesOperators.get(datatype);
    return ops.has(op);
}
async function verifyClaim(merklized, txtSchema, credType, fieldName) {
    let slotIndex;
    let claimPathKey;
    if (merklized === 1) {
        const path = await js_jsonld_merklization_1.Path.getContextPathKey(txtSchema, credType, fieldName);
        path.prepend(['https://www.w3.org/2018/credentials#credentialSubject']);
        claimPathKey = await path.mtEntry();
    }
    else {
        slotIndex = getFieldSlotIndex(fieldName, credType, new TextEncoder().encode(txtSchema));
    }
    return [claimPathKey, slotIndex];
}
async function parsePredicate(predicate, datatype) {
    let operator;
    let values = [];
    for (const [key, value] of Object.entries(predicate)) {
        if (!operators.has(key)) {
            throw new Error(`operator is not supported by lib`);
        }
        operator = operators.get(key);
        if (!isValidOperation(datatype, operator)) {
            throw new Error(`operator '${operator}' is not supported for '${datatype}' datatype`);
        }
        values = await getValuesAsArray(value, datatype);
        break;
    }
    return [operator, values];
}
//# sourceMappingURL=query.js.map