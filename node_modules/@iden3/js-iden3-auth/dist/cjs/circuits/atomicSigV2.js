"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AtomicQuerySigV2PubSignals = void 0;
const query_1 = require("../circuits/query");
const ownershipVerifier_1 = require("../circuits/ownershipVerifier");
const common_1 = require("../circuits/common");
const js_merkletree_1 = require("@iden3/js-merkletree");
const js_iden3_core_1 = require("@iden3/js-iden3-core");
const valuesSize = 64;
const defaultProofVerifyOpts = 1 * 60 * 60 * 1000; // 1 hour
class AtomicQuerySigV2PubSignals extends ownershipVerifier_1.IDOwnershipPubSignals {
    constructor(pubSignals) {
        super();
        this.value = [];
        if (pubSignals.length != 13 + valuesSize) {
            throw new Error(`invalid number of Output values expected ${74} got ${pubSignals.length}`);
        }
        let fieldIdx = 0;
        // -- merklized
        this.merklized = parseInt(pubSignals[fieldIdx]);
        fieldIdx++;
        //  - userID
        this.userId = js_iden3_core_1.Id.fromBigInt(BigInt(pubSignals[fieldIdx]));
        fieldIdx++;
        // - issuerAuthState
        this.issuerAuthState = (0, js_merkletree_1.newHashFromString)(pubSignals[fieldIdx]);
        fieldIdx++;
        // - requestID
        this.challenge = BigInt(pubSignals[fieldIdx]);
        fieldIdx++;
        // - issuerID
        this.issuerID = js_iden3_core_1.Id.fromBigInt(BigInt(pubSignals[fieldIdx]));
        fieldIdx++;
        this.isRevocationChecked = parseInt(pubSignals[fieldIdx]);
        fieldIdx++;
        // - issuerClaimNonRevState
        this.issuerClaimNonRevState = (0, js_merkletree_1.newHashFromString)(pubSignals[fieldIdx]);
        fieldIdx++;
        //  - timestamp
        this.timestamp = parseInt(pubSignals[fieldIdx]);
        fieldIdx++;
        //  - claimSchema
        this.claimSchema = js_iden3_core_1.SchemaHash.newSchemaHashFromInt(BigInt(pubSignals[fieldIdx]));
        fieldIdx++;
        // - ClaimPathNotExists
        this.claimPathNotExists = parseInt(pubSignals[fieldIdx]);
        fieldIdx++;
        // - ClaimPathKey
        this.claimPathKey = BigInt(pubSignals[fieldIdx]);
        fieldIdx++;
        // - slotIndex
        this.slotIndex = parseInt(pubSignals[fieldIdx]);
        fieldIdx++;
        // - operator
        this.operator = parseInt(pubSignals[fieldIdx]);
        fieldIdx++;
        //  - values
        for (let index = 0; index < valuesSize; index++) {
            this.value.push(BigInt(pubSignals[fieldIdx]));
            fieldIdx++;
        }
    }
    async verifyQuery(query, schemaLoader, verifiablePresentation) {
        const outs = {
            issuerId: this.issuerID,
            schemaHash: this.claimSchema,
            slotIndex: this.slotIndex,
            operator: this.operator,
            value: this.value,
            timestamp: this.timestamp,
            merklized: this.merklized,
            claimPathKey: this.claimPathKey,
            claimPathNotExists: this.claimPathNotExists,
            valueArraySize: valuesSize,
            isRevocationChecked: this.isRevocationChecked,
        };
        return await (0, query_1.checkQueryRequest)(query, outs, schemaLoader, verifiablePresentation);
    }
    async verifyStates(resolvers, opts) {
        const resolver = (0, common_1.getResolverByID)(resolvers, this.issuerID);
        if (!resolver) {
            throw new Error(`resolver not found for issuerID ${this.issuerID.string()}`);
        }
        await (0, common_1.checkUserState)(resolver, this.issuerID, this.issuerAuthState);
        if (this.isRevocationChecked === 0) {
            return;
        }
        const issuerNonRevStateResolved = await (0, common_1.checkIssuerNonRevState)(resolver, this.issuerID, this.issuerClaimNonRevState);
        let acceptedStateTransitionDelay = defaultProofVerifyOpts;
        if (opts?.acceptedStateTransitionDelay) {
            acceptedStateTransitionDelay = opts.acceptedStateTransitionDelay;
        }
        if (!issuerNonRevStateResolved.latest) {
            const timeDiff = Date.now() -
                (0, js_iden3_core_1.getDateFromUnixTimestamp)(Number(issuerNonRevStateResolved.transitionTimestamp)).getMilliseconds();
            if (timeDiff > acceptedStateTransitionDelay) {
                throw new Error('issuer state is outdated');
            }
        }
    }
}
exports.AtomicQuerySigV2PubSignals = AtomicQuerySigV2PubSignals;
//# sourceMappingURL=atomicSigV2.js.map