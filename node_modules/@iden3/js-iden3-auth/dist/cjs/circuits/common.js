"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getResolverByDID = exports.getResolverByID = exports.checkIssuerNonRevState = exports.checkGlobalState = exports.checkUserState = exports.gistStateError = exports.userStateError = void 0;
const js_iden3_core_1 = require("@iden3/js-iden3-core");
exports.userStateError = new Error(`user state is not valid`);
exports.gistStateError = new Error(`gist state is not valid`);
async function checkUserState(resolver, userId, userState) {
    const userStateResolved = await resolver.resolve(userId.bigInt(), userState.bigInt());
    if (!userStateResolved.latest) {
        throw exports.userStateError;
    }
    return userStateResolved;
}
exports.checkUserState = checkUserState;
async function checkGlobalState(resolver, state) {
    const gistStateResolved = await resolver.rootResolve(state.bigInt());
    return gistStateResolved;
}
exports.checkGlobalState = checkGlobalState;
async function checkIssuerNonRevState(resolver, issuerId, issuerClaimNonRevState) {
    const issuerNonRevStateResolved = await resolver.resolve(issuerId.bigInt(), issuerClaimNonRevState.bigInt());
    return issuerNonRevStateResolved;
}
exports.checkIssuerNonRevState = checkIssuerNonRevState;
function getResolverByID(resolvers, id) {
    const userDID = js_iden3_core_1.DID.parseFromId(id);
    return getResolverByDID(resolvers, userDID);
}
exports.getResolverByID = getResolverByID;
function getResolverByDID(resolvers, did) {
    return resolvers[`${did.blockchain}:${did.networkId}`];
}
exports.getResolverByDID = getResolverByDID;
//# sourceMappingURL=common.js.map