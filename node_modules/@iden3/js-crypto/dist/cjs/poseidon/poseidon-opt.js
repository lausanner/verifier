"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.poseidon = exports.Poseidon = exports.OPT = void 0;
const ff_1 = require("../ff");
const poseidon_constants_opt_json_1 = __importDefault(require("./poseidon-constants-opt.json"));
exports.OPT = ff_1.utils.unstringifyBigInts(poseidon_constants_opt_json_1.default);
const N_ROUNDS_F = 8;
const N_ROUNDS_P = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];
const SPONGE_INPUTS = 16;
const SPONGE_CHUNK_SIZE = 31;
const F = new ff_1.F1Field(ff_1.Scalar.fromString('21888242871839275222246405745257275088548364400416034343698204186575808495617'));
const pow5 = (a) => F.mul(a, F.square(F.square(a, a)));
// circomlibjs Poseidon bn128
class Poseidon {
    static hash(inputs) {
        if (!(inputs.length > 0 && inputs.length <= N_ROUNDS_P.length)) {
            throw new Error('Invalid inputs');
        }
        const t = inputs.length + 1;
        const nRoundsF = N_ROUNDS_F;
        const nRoundsP = N_ROUNDS_P[t - 2];
        const C = exports.OPT.C[t - 2];
        const S = exports.OPT.S[t - 2];
        const M = exports.OPT.M[t - 2];
        const P = exports.OPT.P[t - 2];
        let state = [F.zero, ...inputs.map((a) => F.e(a))];
        state = state.map((a, i) => F.add(a, C[i]));
        for (let r = 0; r < nRoundsF / 2 - 1; r++) {
            state = state.map((a) => pow5(a));
            state = state.map((a, i) => F.add(a, C[(r + 1) * t + i]));
            state = state.map((_, i) => state.reduce((acc, a, j) => F.add(acc, F.mul(M[j][i], a)), F.zero));
        }
        state = state.map((a) => pow5(a));
        state = state.map((a, i) => F.add(a, C[(nRoundsF / 2 - 1 + 1) * t + i]));
        state = state.map((_, i) => state.reduce((acc, a, j) => F.add(acc, F.mul(P[j][i], a)), F.zero));
        for (let r = 0; r < nRoundsP; r++) {
            state[0] = pow5(state[0]);
            state[0] = F.add(state[0], C[(nRoundsF / 2 + 1) * t + r]);
            const s0 = state.reduce((acc, a, j) => {
                return F.add(acc, F.mul(S[(t * 2 - 1) * r + j], a));
            }, F.zero);
            for (let k = 1; k < t; k++) {
                state[k] = F.add(state[k], F.mul(state[0], S[(t * 2 - 1) * r + t + k - 1]));
            }
            state[0] = s0;
        }
        for (let r = 0; r < nRoundsF / 2 - 1; r++) {
            state = state.map((a) => pow5(a));
            state = state.map((a, i) => F.add(a, C[(nRoundsF / 2 + 1) * t + nRoundsP + r * t + i]));
            state = state.map((_, i) => state.reduce((acc, a, j) => F.add(acc, F.mul(M[j][i], a)), F.zero));
        }
        state = state.map((a) => pow5(a));
        state = state.map((_, i) => state.reduce((acc, a, j) => F.add(acc, F.mul(M[j][i], a)), F.zero));
        return F.normalize(state[0]);
    }
    static hashBytes(msg) {
        const inputs = new Array(SPONGE_INPUTS).fill(BigInt(0));
        let dirty = false;
        let hash;
        let k = 0;
        for (let i = 0; i < parseInt(`${msg.length / SPONGE_CHUNK_SIZE}`); i += 1) {
            dirty = true;
            inputs[k] = ff_1.utils.beBuff2int(msg.slice(SPONGE_CHUNK_SIZE * i, SPONGE_CHUNK_SIZE * (i + 1)));
            if (k === SPONGE_INPUTS - 1) {
                hash = Poseidon.hash(inputs);
                dirty = false;
                inputs[0] = hash.valueOf();
                inputs.fill(BigInt(0), 1, SPONGE_CHUNK_SIZE);
                for (let j = 1; j < SPONGE_INPUTS; j += 1) {
                    inputs[j] = BigInt(0);
                }
                k = 1;
            }
            else {
                k += 1;
            }
        }
        if (msg.length % SPONGE_CHUNK_SIZE != 0) {
            const buff = new Uint8Array(SPONGE_CHUNK_SIZE);
            const slice = msg.slice(parseInt(`${msg.length / SPONGE_CHUNK_SIZE}`) * SPONGE_CHUNK_SIZE);
            slice.forEach((v, idx) => {
                buff[idx] = v;
            });
            inputs[k] = ff_1.utils.beBuff2int(buff);
            dirty = true;
        }
        if (dirty) {
            // we haven't hashed something in the main sponge loop and need to do hash here
            hash = Poseidon.hash(inputs);
        }
        // @ts-ignore: if we reach here then hash should be assigned value
        return hash.valueOf();
    }
}
exports.Poseidon = Poseidon;
Poseidon.F = F;
exports.poseidon = Poseidon;
//# sourceMappingURL=poseidon-opt.js.map